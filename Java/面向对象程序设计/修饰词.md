#### 1. 修饰词final
在Java中的意思是“最终的”或“不可改变的”，用于表示对象是最终形态的，不可改变。在类的继承、方法的重写以及变量的赋值中，`final`都提供了额外的约束和保证。
- 修饰类时，类不能被继承；
- 修饰方法时，方法不能被重写；
- 修饰变量时，变量只能被赋值一次；
#### 2. 修饰词abstract
表示“抽象的”，只能用来修饰类和方法，不能修饰属性。
- 当abstract修饰类时，表示该类是一个抽象类。抽象类不能生成实例，但可以作为对象变量声明的类型，即编译时类型。抽象类相当于类的半成品，需要子类继承并覆盖其中的方法。抽象类虽然不能实例化，但是有自己的构造方法。
- 当abstract修饰方法时，表示该方法是一个抽象方法==。**抽象方法只有方法的定义，没有方法的实现**。==抽象方法只有方法的声明，没有方法体，需要子类重写。**包含抽象方法的类一定是抽象类，但是抽象类不一定有抽象方法，抽象方法只能在抽象类中。**如果父类是抽象类，其中有抽象方法，那么子类继承父类后，需要把父类中的所有抽象方法都实现了，子类才有创建对象实例的能力，否则子类也必须是抽象类。![[capture_20240521085227294.bmp]]
$$
含有抽象方法的类属于（被包含）抽象类
$$
#### 3. 修饰词static
意为“静态”，用于表示属于类本身，而不是类的实例。主要是相对于实例而言。隶属于类，用类调用，如System(类名).out（类变量）.println（）（方法）.
在Java中，`static`是一个修饰词，它可以用来修饰类变量、类方法（也称为静态方法）、代码块（静态初始化块）以及内部类。使用`static`修饰的元素属于类本身，而不是类的某个实例。
- 静态变量（类变量）
静态变量是类的变量，而不是实例的变量。这意味着静态变量只有一个副本，不论创建多少个类的对象，静态变量都只有一份。静态变量在类加载时初始化，而不是在创建类的对象时初始化。

```java
public class MyClass {
    static int staticVar = 42; // 静态变量
    int instanceVar = 0; // 实例变量
}
```

你可以通过类名直接访问静态变量，而不需要创建类的对象。

```java
int value = MyClass.staticVar; // 正确
// MyClass.instanceVar; // 错误，因为instanceVar是实例变量
```

- 静态方法（类方法）
静态方法是属于类的方法，而不是属于类的实例的方法。静态方法不能访问类的非静态成员（变量和方法），因为静态方法不依赖于类的实例。静态方法可以通过类名直接调用。

```java
public class MyClass {
    static void staticMethod() {
        // ...
    }

    void instanceMethod() {
        // ...
    }
}

MyClass.staticMethod(); // 正确
// MyClass.instanceMethod(); // 错误，因为instanceMethod是实例方法
```

- 静态初始化块
静态初始化块在类加载时执行，并且只执行一次。它通常用于初始化静态变量。

```java
public class MyClass {
    static int staticVar;

    static {
        staticVar = 42;
        // 其他的初始化代码...
    }
}
```

- 静态内部类
静态内部类是定义在另一个类内部的类，并且使用`static`修饰。静态内部类可以不依赖于外部类的实例而被实例化。静态内部类不能访问外部类的非静态成员，但可以访问外部类的静态成员。

```java
public class OuterClass {
    static int outerStaticVar = 42;

    static class StaticNestedClass {
        void display() {
            System.out.println(OuterClass.outerStaticVar);
        }
    }
}

OuterClass.StaticNestedClass nested = new OuterClass.StaticNestedClass();
nested.display(); // 输出 42
```

- 注意事项
 静态变量和静态方法可以通过类名直接访问，而不需要创建类的对象。
 静态方法不能访问类的非静态成员（变量和方法），因为静态方法不依赖于类的实例。
 ==在Java中，静态方法（如`main`方法）不能直接调用非静态方法或访问非静态变量==，除非通过创建类的实例（即对象）来调用。这是因为非静态方法和变量与特定对象实例相关联，而静态方法和变量则与类本身相关联。
 静态初始化块在类加载时执行，并且只执行一次。
 静态内部类可以不依赖于外部类的实例而被实例化，但不能访问外部类的非静态成员。
